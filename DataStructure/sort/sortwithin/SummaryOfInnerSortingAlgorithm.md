## 排序算法的稳定性
### 稳定的排序算法
1. 直接插入排序 
2. 二分法插入排序
3. 表插入排序
4. 冒泡排序

### 不稳定的排序算法

1. shell插入排序
2. 直接选择排序
3. 堆排序

## 时间复杂度与排序算法之间的对比

1. 直接插入排序——$$O(n^2)$$

2. 二分法插入排序——$$O(n^2)$$

   ①与**直接插入排序**的比较次数对比：二分法插入的比较次数少于直接插入排序的最多比较次数，而一般要多于直接插入排序的最少比较次数。总体上讲，当n较大时，二分法插入排序的比较次数**远少于**直接插入排序的平均比较次数，但二者所要进行的移动次数**相等**，故二分法插入排序的时间复杂度为——$$O(n^2)$$，所需的附加存储空间为**一个记录空间**。

3. 表插入排序——$$O(n^2)$$

   ①表插入排序**没有记录的移动**，但是**增加了link域**，进行了**2n**次**修改link值**的操作。因为比较次数和直接插入排序算法的情况相同，所有表插入排序的时间复杂度为$$O(n^2)$$

4. Shell插入排序——很难给出

   ①Shell排序一般而言要比直接插入排序快，但要给出时间复杂度的分析相当难。至今为止也没有找到一个最好的缩小增量序列的选取方法。

5. 直接选择排序——$$O(n^2)$$

   ①在每次选择最小排序码的过程中，对于第 i 次选择，因为算法内循环要执行 n-i 次比较，所以算法的总比较次数为$$\sum_{i=1}^{n-1}(i)=1+2+3+\cdots+(n-1)=\frac{n\times(n-1)}{2}$$。关于算法所发送的移动次数，当待排序文件初始就是有序文件时，该算法不需要进行任何移动操作，而在特殊情况下，外循环循环体每一次执行都要进行 3 次移动记录的操作，故最坏情况下共要进行$$3(n-1)$$次记录的移动。因此，直接选择排序的时间复杂度为$$O(n^2)$$。该算法使用了存储**一个记录的附加空间**。

   直接选择排序是不稳定的。例如，当排序初始码初始序列为112，112，50时，两个排序码相同的记录经过直接选择排序后相对位置就改变了。

6. 树型选择排序——约等于$$O(n\log_2n)$$

   ①与简单选择排序算法相比，降低了比较次数的数量级，增加了n-1个额外的存储空间存放中间比较结果。

7. 堆排序——$$o(n\log_2n)$$

   ①堆排序方法对记录数 n 较大的文件排序是很好的，**但当 n 较小时，不提倡使用**，因为初始建堆和调整建新堆时要反复的筛选。堆排序时间复杂度为 $$o(n\log_2n)$$ ，可根据二叉树特点分析出来。堆排序只需要存放**一个**记录的**附加空间**。

8. 冒泡排序——$$O(n^2)$$

   当初始时各记录已有序（第二种改进版代码），则进行一趟两两比较，即 while 循环体只执行一次，算法结束，其中 for 循环中要比较 n-1 次，移动次数为 0。而当初始各记录是按从大到小排序，该算法中 while 循环体要执行 n-1 次，即要进行 n-1 趟比较。第 i 趟比较中， for 循环体中比较 n-i 次，总的比较次数为：$$\sum_{i=1}^{n-1}(n-i)=\frac{(n-1)\times{n}}{2}$$，交换次数为$$\frac{{n}\times(n-1)\times{3}}{2}$$。所以，冒泡排序算法的时间复杂度  $$O(n^2)$$，并且其需要的空间为存放 1 个记录的附加存储空间。

9. 快速排序——