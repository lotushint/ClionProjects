## 排序算法的稳定性
### 稳定的排序算法
1. 直接插入排序 

2. 二分法插入排序

3. 表插入排序

### 不稳定的排序算法

1. shell插入排序
2. 直接选择排序

## 时间复杂度与排序算法之间的对比

1. 直接插入排序——$$O(n^2)$$

2. 二分法插入排序——$$O(n^2)$$

   ①与**直接插入排序**的比较次数对比：二分法插入的比较次数少于直接插入排序的最多比较次数，而一般要多于直接插入排序的最少比较次数。总体上讲，当n较大时，二分法插入排序的比较次数**远少于**直接插入排序的平均比较次数，但二者所要进行的移动次数**相等**，故二分法插入排序的时间复杂度为——$$O(n^2)$$，所需的附加存储空间为**一个记录空间**。

3. 表插入排序——$$O(n^2)$$

   ①表插入排序**没有记录的移动**，但是**增加了link域**，进行了**2n**次**修改link值**的操作。因为比较次数和直接插入排序算法的情况相同，所有表插入排序的时间复杂度为$$O(n^2)$$

4. Shell插入排序——很难给出

   ①Shell排序一般而言要比直接插入排序快，但要给出时间复杂度的分析相当难。至今为止也没有找到一个最好的缩小增量序列的选取方法。

5. 直接选择排序——$$O(n^2)$$

   ①在每次选择最小排序码的过程中，对于第 i 次选择，因为算法内循环要执行 n-i 次比较，所以算法的总比较次数为$$\sum_{i=1}^{n-1}(i)=1+2+3+\cdots+(n-1)=\frac{n\times(n-1)}{2}$$。关于算法所发送的移动次数，当待排序文件初始就是有序文件时，该算法不需要进行任何移动操作，而在特殊情况下，外循环循环体每一次执行都要进行 3 次移动记录的操作，故最坏情况下共要进行$$3(n-1)$$次记录的移动。因此，直接选择排序的时间复杂度为$$O(n^2)$$。该算法使用了存储**一个记录的附加空间**。

   直接选择排序是不稳定的。例如，当排序初始码初始序列为112，112，50时，两个排序码相同的记录经过直接选择排序后相对位置就改变了。

6. 树型选择排序——约等于$$O(n\log_2n)$$

   ①与简单选择排序算法相比，降低了比较次数的数量级，增加了n-1个额外的存储空间存放中间比较结果。